sorteo_project/settings.py:
# sorteo_project/settings.py



"""
Django settings for sorteo_project project.

Generated by 'django-admin startproject' using Django 5.1.5.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-cm6t-6dcw07k0z1(fbbk$8we7y1sa-y2gxeim-mi^)to)jdwv8"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    # Apps predeterminadas de Django
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Apps de terceros
    'rest_framework',
    'channels',
    'corsheaders',

    # Tu app
    'sorteo_app',
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    'corsheaders.middleware.CorsMiddleware',  # Si usas django-cors-headers
]

# Configurar Channels
ASGI_APPLICATION = 'sorteo_project.asgi.application'

# Configurar el backend de canales (por defecto, usa en memoria)
# Para producción, considera usar Redis
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            'hosts': [('127.0.0.1', 6379)],
        },
    },
}

# Configurar CORS
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    # Añade otros orígenes si es necesario
]

CORS_ALLOW_ALL_ORIGINS = True
# O, en versiones anteriores: CORS_ORIGIN_ALLOW_ALL = True

ROOT_URLCONF = "sorteo_project.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "sorteo_project.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = 'America/Argentina/Buenos_Aires'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = "static/"

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


**************************
sorteo_project/asgi.py:
# sorteo_project/asgi.py

import os
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
from django.core.asgi import get_asgi_application
import sorteo_app.routing

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "sorteo_project.settings")

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AuthMiddlewareStack(
        URLRouter(sorteo_app.routing.websocket_urlpatterns)
    ),
})


**************************
sorteo_project/urls.py:
# sorteo_project/urls.py

from django.contrib import admin
from django.urls import path, include
from rest_framework import routers
from sorteo_app.views import (
    UploadCSVView,
    realizar_sorteo,
    ListadoSorteos,
    ListadoResultadosSorteo,
    ListadoRegistroActividad,
    listar_provincias, 
    listar_localidades
)
from sorteo_app.views.views_sorteo import PremioViewSet

router = routers.DefaultRouter()
router.register(r'premios', PremioViewSet, basename='premio')

urlpatterns = [
    path('admin/', admin.site.urls),

    # SUBIDA CSV (POST con drag & drop)
    path('api/upload_csv/', UploadCSVView.as_view(), name='upload_csv'),

    # SORTEO (POST con parámetros)
    path('api/sortear/', realizar_sorteo, name='realizar_sorteo'),

    # HISTÓRICO / LISTAS
    path('api/sorteos/', ListadoSorteos.as_view(), name='listado_sorteos'),
    path('api/resultados_sorteo/', ListadoResultadosSorteo.as_view(), name='listado_resultados_sorteo'),
    path('api/registro_actividad/', ListadoRegistroActividad.as_view(), name='listado_registro_actividad'),
    path('api/provincias/', listar_provincias, name='listar_provincias'),
    path('api/localidades/', listar_localidades, name='listar_localidades'),

    # Incluir las rutas del router
    path('api/', include(router.urls)),
]


**************************
sorteo_app/models.py:
# sorteo_app/models.py

from django.db import models
from django.contrib.auth.models import User  # Importa el modelo de usuario incorporado
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils import timezone  # Asegúrate de importar timezone si lo necesitas

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    localidad = models.CharField(max_length=255)
    provincia = models.CharField(max_length=255)

    def __str__(self):
        return f'Perfil de {self.user.username}'

@receiver(post_save, sender=User)
def crear_guardar_perfil(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)
    instance.profile.save()

class Premio(models.Model):
    nombre = models.CharField(max_length=255, unique=True)
    stock = models.PositiveIntegerField(default=0)

    def __str__(self):
        return self.nombre


class Sorteo(models.Model):
    nombre = models.CharField(max_length=255)
    descripcion = models.TextField(blank=True)
    premios = models.ManyToManyField(Premio, through='SorteoPremio')
    fecha_hora = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.nombre

class SorteoPremio(models.Model):
    sorteo = models.ForeignKey(Sorteo, on_delete=models.CASCADE, related_name='sorteopremios')
    premio = models.ForeignKey(Premio, on_delete=models.CASCADE, related_name='sorteopremios')
    orden_item = models.PositiveIntegerField()
    cantidad = models.PositiveIntegerField()

    class Meta:
        unique_together = ('sorteo', 'premio')
        ordering = ['orden_item']

    def __str__(self):
        return f'{self.premio.nombre} en {self.sorteo.nombre} - Orden: {self.orden_item}, Cantidad: {self.cantidad}'

class ResultadoSorteo(models.Model):
    sorteo = models.ForeignKey(Sorteo, on_delete=models.CASCADE)
    usuario = models.ForeignKey(User, on_delete=models.CASCADE)
    premio = models.ForeignKey(Premio, on_delete=models.CASCADE)
    fecha = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f'{self.usuario} ganó {self.premio} en {self.sorteo}'

class RegistroActividad(models.Model):
    evento = models.CharField(max_length=255)
    fecha_hora = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f'{self.evento} at {self.fecha_hora}'


**************************
sorteo_app/serializers.py:
# sorteo_app/serializers.py

from rest_framework import serializers
from django.contrib.auth.models import User
from .models import RegistroActividad, Sorteo, SorteoPremio, ResultadoSorteo, Premio, UserProfile

class UserProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = UserProfile
        fields = ['localidad', 'provincia']

class UserSerializer(serializers.ModelSerializer):
    profile = UserProfileSerializer()

    class Meta:
        model = User
        fields = ['id', 'username', 'first_name', 'last_name', 'email', 'profile']

class RegistroActividadSerializer(serializers.ModelSerializer):
    class Meta:
        model = RegistroActividad
        fields = '__all__'

class PremioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Premio
        fields = ['id', 'nombre', 'stock']

class SorteoPremioSerializer(serializers.ModelSerializer):
    premio = PremioSerializer(read_only=True)
    premio_id = serializers.PrimaryKeyRelatedField(queryset=Premio.objects.all(), source='premio', write_only=True)

    class Meta:
        model = SorteoPremio
        fields = ['premio', 'premio_id', 'orden_item', 'cantidad']

class SorteoSerializer(serializers.ModelSerializer):
    sorteopremios = SorteoPremioSerializer(many=True)

    class Meta:
        model = Sorteo
        fields = ['id', 'nombre', 'descripcion', 'fecha_hora', 'sorteopremios']

    def create(self, validated_data):
        premios_data = validated_data.pop('sorteopremios')
        sorteo = Sorteo.objects.create(**validated_data)
        for premio_data in premios_data:
            premio = premio_data['premio']
            orden_item = premio_data['orden_item']
            cantidad = premio_data['cantidad']

            # Verificar stock
            if premio.stock < cantidad:
                raise serializers.ValidationError(f'No hay suficiente stock para el premio {premio.nombre}')

            # Reducir stock
            premio.stock -= cantidad
            premio.save()

            # Crear relación SorteoPremio
            SorteoPremio.objects.create(
                sorteo=sorteo,
                premio=premio,
                orden_item=orden_item,
                cantidad=cantidad
            )
        return sorteo
    
class ResultadoSorteoSerializer(serializers.ModelSerializer):
    usuario = UserSerializer(read_only=True)
    premio = PremioSerializer(read_only=True)

    class Meta:
        model = ResultadoSorteo
        fields = ['id', 'sorteo', 'usuario', 'premio', 'fecha']


**************************
sorteo_app/views/views_filters.py:
# sorteo_app/views/views_filters.py

from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from django.contrib.auth.models import User

@api_view(['GET'])
def listar_provincias(request):
    """
    Retorna la lista de todas las provincias únicas 
    que existen en el perfil de Usuario.
    """
    provincias = User.objects.values_list('profile__provincia', flat=True).distinct()
    provincias_list = sorted(provincias)
    return Response(provincias_list, status=status.HTTP_200_OK)

@api_view(['GET'])
def listar_localidades(request):
    """
    GET /api/localidades/?provincia=Buenos Aires

    Retorna la lista de localidades únicas para la provincia
    indicada (opcional). Si no se pasa provincia, retorna
    todas las localidades únicas.
    """
    provincia = request.GET.get('provincia')

    if provincia:
        localidades = User.objects.filter(
            profile__provincia__iexact=provincia
        ).values_list('profile__localidad', flat=True).distinct()
    else:
        localidades = User.objects.values_list('profile__localidad', flat=True).distinct()

    localidades_list = sorted(localidades)
    return Response(localidades_list, status=status.HTTP_200_OK)


**************************
sorteo_app/views/views_sorteo.py:
# sorteo_app/views/views_sorteo.py

import random
from rest_framework.decorators import api_view, action
from rest_framework.response import Response
from rest_framework import status, viewsets
from rest_framework.generics import ListAPIView
from django.shortcuts import get_object_or_404
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
import json

# Importa tus modelos
from ..models import RegistroActividad, Sorteo, SorteoPremio, ResultadoSorteo, Premio
from django.contrib.auth.models import User

# Importa tus serializers
from ..serializers import (
    SorteoSerializer,
    ResultadoSorteoSerializer,
    RegistroActividadSerializer,
    PremioSerializer,
    SorteoPremioSerializer,
    UserSerializer
)

# ViewSet para gestionar Premios
class PremioViewSet(viewsets.ModelViewSet):
    queryset = Premio.objects.all()
    serializer_class = PremioSerializer

# API para realizar el sorteo
@api_view(['POST'])
def realizar_sorteo(request):
    """
    Recibe un JSON con la siguiente estructura:
    {
      "nombre": "Sorteo Especial 2025",
      "descripcion": "Fin de año con varios premios.",
      "provincia": "Santa Fe",  # opcional
      "localidad": "Rosario",   # opcional
      "premios": [
        {"premio_id": 1, "orden_item": 1, "cantidad": 2},
        {"premio_id": 2, "orden_item": 2, "cantidad": 1},
        {"premio_id": 3, "orden_item": 3, "cantidad": 1}
      ]
    }
    """
    print("Datos recibidos en el backend:", request.data)  # <-- Agregado

    serializer = SorteoSerializer(data=request.data)
    if serializer.is_valid():
        try:
            sorteo = serializer.save()
        except serializers.ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

        # Realizar el sorteo
        # Filtrar usuarios según provincia y localidad si se especifican
        provincia = request.data.get('provincia')
        localidad = request.data.get('localidad')

        queryset = User.objects.all()
        if provincia:
            queryset = queryset.filter(profile__provincia__iexact=provincia)
        if localidad:
            queryset = queryset.filter(profile__localidad__iexact=localidad)

        usuarios_disponibles = list(queryset)

        if not usuarios_disponibles:
            return Response({'error': 'No hay usuarios que cumplan el filtro.'}, status=status.HTTP_400_BAD_REQUEST)

        # Calcular la suma total de premios
        total_premios = sum(p['cantidad'] for p in request.data.get('premios', []))
        if total_premios > len(usuarios_disponibles):
            return Response({'error': 'No hay suficientes usuarios para la cantidad total de premios.'}, status=status.HTTP_400_BAD_REQUEST)

        # Mezclar usuarios para aleatoriedad
        random.shuffle(usuarios_disponibles)

        # Asignar ganadores
        ganadores_info = []
        premios_sorted = SorteoPremio.objects.filter(sorteo=sorteo).order_by('orden_item')

        for sorteo_premio in premios_sorted:
            cantidad = sorteo_premio.cantidad
            premio = sorteo_premio.premio

            if cantidad > len(usuarios_disponibles):
                return Response({'error': f'No hay suficientes usuarios para asignar el premio {premio.nombre}.'}, status=status.HTTP_400_BAD_REQUEST)

            ganadores = usuarios_disponibles[:cantidad]
            usuarios_disponibles = usuarios_disponibles[cantidad:]

            ganadores_data = []
            for ganador in ganadores:
                ResultadoSorteo.objects.create(
                    sorteo=sorteo,
                    usuario=ganador,
                    premio=premio
                )
                ganadores_data.append({
                    'id_ganador': ganador.id,
                    'nombre': ganador.first_name,
                    'apellido': ganador.last_name,
                    'email': ganador.email,
                })

            ganadores_info.append({
                'nombre_item': premio.nombre,
                'orden_item': sorteo_premio.orden_item,
                'cantidad': cantidad,
                'ganadores': ganadores_data
            })

        # Registrar actividad en RegistroActividad
        RegistroActividad.objects.create(
            evento=f"Sorteo (ID={sorteo.id}) '{sorteo.nombre}' con {premios_sorted.count()} premios y un total de {total_premios} ganadores."
        )

        # Notificar a los clientes conectados vía WebSocket
        channel_layer = get_channel_layer()
        sorteo_data = SorteoSerializer(sorteo).data
        async_to_sync(channel_layer.group_send)(
            'sorteos',
            {
                'type': 'send_sorteo',
                'sorteo': sorteo_data
            }
        )

        # Preparar la respuesta
        data_response = {
            'sorteo_id': sorteo.id,
            'nombre_sorteo': sorteo.nombre,
            'items': ganadores_info
        }

        return Response(data_response, status=status.HTTP_200_OK)
    else:
        print("Errores de validación:", serializer.errors)  # <-- Agregado
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

# Vistas para Listado de Sorteos, Resultados y Actividad
class ListadoSorteos(ListAPIView):
    """
    Devuelve la lista de todos los sorteos, ordenados por fecha_hora descendente.
    GET /api/sorteos/
    """
    queryset = Sorteo.objects.all().order_by('-fecha_hora')
    serializer_class = SorteoSerializer

class ListadoResultadosSorteo(ListAPIView):
    """
    Devuelve la lista de todos los objetos ResultadoSorteo
    (cada registro asocia un sorteo con un usuario ganador y el premio).
    GET /api/resultados_sorteo/
    """
    queryset = ResultadoSorteo.objects.all()
    serializer_class = ResultadoSorteoSerializer

class ListadoRegistroActividad(ListAPIView):
    """
    Muestra el historial de eventos (cargas de usuarios, sorteos realizados, etc.)
    GET /api/registro_actividad/
    """
    queryset = RegistroActividad.objects.all().order_by('-fecha_hora')
    serializer_class = RegistroActividadSerializer


**************************
sorteo_app/views/views_upload.py:
# sorteo_app/views/views_upload.py

import csv
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.db import transaction
from io import TextIOWrapper
from django.contrib.auth.models import User
from ..models import RegistroActividad, UserProfile

class UploadCSVView(APIView):
    """
    Endpoint para subir usuarios.csv y lista_negra.csv via POST.
    """
    def post(self, request, format=None):
        # Espera: files={'usuarios': <File>, 'lista_negra': <File>}
        file_usuarios = request.FILES.get('usuarios')
        file_lista_negra = request.FILES.get('lista_negra')

        if not file_usuarios or not file_lista_negra:
            return Response(
                {'error': 'Faltan archivos usuarios o lista_negra.'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Parsear lista negra
        blacklist_ids = set()
        try:
            text_file_ln = TextIOWrapper(file_lista_negra.file, encoding='utf-8')
            reader_ln = csv.DictReader(text_file_ln)
            for row in reader_ln:
                try:
                    blacklist_ids.add(int(row['ID']))
                except ValueError:
                    return Response(
                        {'error': f'ID inválido en lista_negra: {row.get("ID")}'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
        except Exception as e:
            return Response({'error': f'Error al procesar lista_negra.csv: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

        # Cargar usuarios
        contador = 0
        errores = []
        try:
            text_file_u = TextIOWrapper(file_usuarios.file, encoding='utf-8')
            reader_u = csv.DictReader(text_file_u)

            with transaction.atomic():
                for row in reader_u:
                    try:
                        user_id = int(row['ID'])
                        if user_id in blacklist_ids:
                            continue

                        # Obtener o crear el usuario
                        user, created = User.objects.update_or_create(
                            id=user_id,
                            defaults={
                                'username': row['Username'],  # Asegúrate de que el CSV tenga una columna 'Username'
                                'first_name': row['Nombre'],
                                'last_name': row['Apellido'],
                                'email': row['Email'],
                            }
                        )

                        # Actualizar o crear el perfil
                        UserProfile.objects.update_or_create(
                            user=user,
                            defaults={
                                'localidad': row['Localidad'],
                                'provincia': row['Provincia']
                            }
                        )

                        contador += 1
                    except KeyError as e:
                        errores.append({'row': row, 'error': f'Campo faltante: {e}'})
                    except ValueError:
                        errores.append({'row': row, 'error': f'ID inválido: {row.get("ID")}'})
                    except Exception as e:
                        errores.append({'row': row, 'error': str(e)})

        except Exception as e:
            return Response({'error': f'Error al procesar usuarios.csv: {str(e)}'}, status=status.HTTP_400_BAD_REQUEST)

        # Registrar actividad
        RegistroActividad.objects.create(
            evento=f"Se cargaron/actualizaron {contador} usuarios. Excluidos {len(blacklist_ids)} IDs."
        )

        response_data = {
            'mensaje': f'Se cargaron {contador} usuarios.',
            'excluidos': len(blacklist_ids),
            'errores': errores  # Lista de errores encontrados
        }

        return Response(response_data, status=status.HTTP_200_OK)


**************************
sorteo_app/routing.py:
# sorteo_project/routing.py

from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
import sorteo_app.routing

application = ProtocolTypeRouter({
    'websocket': AuthMiddlewareStack(
        URLRouter(
            sorteo_app.routing.websocket_urlpatterns
        )
    ),
})


**************************
sorteo_app/consumers.py:
# sorteo_app/consumers.py

import json
from channels.generic.websocket import AsyncWebsocketConsumer

class SorteoConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.group_name = 'sorteos'

        # Unirse al grupo de sorteos
        await self.channel_layer.group_add(
            "sorteos", self.channel_name
        )
        # await self.channel_layer.group_add(
        #     self.group_name,
        #     self.channel_name
        # )

        await self.accept()

    async def disconnect(self, close_code):
        # Salir del grupo de sorteos

        await self.channel_layer.group_discard(
            "sorteos", self.channel_name
        )
        # await self.channel_layer.group_discard(
        #     self.group_name,
        #     self.channel_name
        # )

    # Recibir mensaje del grupo
    async def send_sorteo(self, event):
        sorteo_data = event['sorteo']

        # Enviar mensaje al WebSocket

        await self.send(text_data=json.dumps({
            "type": "sorteo", 
            "sorteo": event["sorteo"]
        }))
        # await self.send(text_data=json.dumps({
        #     'type': 'sorteo',
        #     'sorteo': sorteo_data
        # }))
